//    someNumber: {
//             "type": "number",
//             "anyOf": [
//                 {
//                     "type": "number",
//                     "title": "one",
//                     "enum": [
//                         1
//                     ]
//                 },
//                 {
//                     "type": "number",
//                     "title": "two",
//                     "enum": [
//                         2
//                     ]
//                 },
//                 {
//                     "type": "number",
//                     "title": "three",
//                     "enum": [
//                         3
//                     ]
//                 }
//             ]
//         },

// Note:

// input text => where user can input we can validate input (rules are per user given)
// dependency check
// dropdown with multiple choices =>  need tick mark => we need to do customize
// single and multiple select checkbox

// add searchable dropdown
// add ReadOnly (not Editable)
// customize example: input box with searchable icon,
// instead of highlighting the dropdown provide tick mark

// const schema: RJSFSchema = {
//   type: 'object',
//   "title": "My title",
//   "description": "My description",
//   properties: {
//     firstName: {
//       type: 'string',
//       title: 'First Name',
//       minLength: 10,
//       default: "abcdefghijkl" // which set value to the input field
//     },
//     lastName: {
//       type: 'string',
//       title: 'Last Name',
//       maxLength: 4
//     },
//     age: {
//       type: 'number',
//       title: 'Age',
//     },
//     password: {
//       type: 'string',
//       title: 'Password',
//       minLength: 8, // Minimum length requirement
//       pattern: '^(?=.*[A-Za-z])(?=.*\\d)[A-Za-z\\d!$%@#£€*?&]+$',
//       description:
//         'At least 8 characters, including at least one letter and one number.'
//     },
//     additionalItems: {
//       type: "boolean"
//     },
//     check: {
//       type: "string",
//       enum: ["one", "two", "three"]
//     },
//     multiChoiceWithCheckBox: {
//       type: "array",
//       title: "A multiple-choice list With Checkboxes",
//       items: {
//         type: "string",
//         enum: ["foo", "bar", "fuzz", "qux"],
//       },
//       uniqueItems: true
//     },
//     multiChoiceWithArray: {
//       type: "array",
//       title: "A multiple-choice list With Array",
//       items: {
//         type: "string",
//         enum: ["foo", "bar", "fuzz", "qux"],
//       },
//       uniqueItems: true
//     },
//     done: {
//       type: "string",
//       enum: ["foo", "bar", "fuzz", "qux"],
//     },
//     fileUpload: {
//       type: "string",
//       format: "data-url",
//     }
//   },
//   // "required": ["firstName", "age", "additionalItems"],
//   "dependencies": {
//     "firstName": ["lastName"]
//   }
// };

// const uiSchema: UiSchema = {
//   "ui:order": ["firstName", "lastName", "age", "password", "multiChoiceWithArray", "someNumber", "check", "multiChoiceWithCheckBox", "additionalItems", "done", "fileUpload"],
//   multiChoiceWithCheckBox: {
//     "ui:widget": "checkboxes",
//     "ui:options": {
//       inline: true,
//       addable: false
//     }
//     // "ui:options": {

//     // },
//   },
//   fileUpload: {
//     "ui:widget": "file",
//     "ui:options": { accept: ".pdf" }
//   },
//   done: {
//     "ui:widget": "radio" // could also be "select"
//   },
//   password: {
//     'ui:widget': 'password'
//   },
//   firstName: {
//     'ui:placeholder': 'Enter your first name',
//     "ui:autofocus": true,
//     required: true
//   },
//   lastName: {
//     'ui:placeholder': 'Enter your last name',
//     // 'ui:readonly': true,
//   },
//   age: {
//     "ui:help": "The Age that can be used to contact you"
//   }
// };

// setTimeout(() => {
//   monaco?.editor.getEditors().forEach((editor: any) => {
//     editor.setPosition({ lineNumber: event.changes[0]?.range.startLineNumber, column: +(event.changes[0]?.range.startColumn) + 1 })
//   })
// }, 10)
// setTimeout(() => {
//   monaco?.editor.getEditors().forEach((editor) => {
//     if (event.changes[0]?.text === '') {
//       // Backspace or delete key was pressed
//       editor.setPosition({
//         lineNumber: event.changes[0]?.range.startLineNumber,
//         column: event.changes[0]?.range.startColumn
//       })
//     } else {
//       // Any other key was pressed
//       editor.setPosition({
//         lineNumber: event.changes[0]?.range.startLineNumber,
//         column: +(event.changes[0]?.range.startColumn) + 1
//       })
//     }
//   })
// }, 10)

// import React, { memo, useCallback, useEffect, useState } from 'react'
// import Form from '@rjsf/mui'
// import validator from '@rjsf/validator-ajv8'
// import { isEmpty, isFunction, isObject } from 'lodash'
// import { Alert } from '@mui/material'
// import { type FormProps } from '@rjsf/core'
// import { type RJSFSchema } from '@rjsf/utils'
// import SplitterLayout from 'react-splitter-layout'
// import SearchBox from './components/SearchBox'
// import Editors from './components/Editor'
// import LoadingOverlay from '../utilities/Loader'
// import { useOrientation } from '../utilities/withOrientationEffect'
// import CustomModal from './components/Modal'
// import ResetAll from './components/ResetSpec'
// import ReactToastMessage from '../utilities/ReactToastMessage'

// interface IFunctionCallerProps extends FormProps<any, RJSFSchema, any> {
//   getStoreList: [] | (() => []) | (() => Promise<any[]>)
//   onLoadSchema: Record<string, unknown> | (() => Record<string, unknown>) | (() => Promise<Record<string, unknown>>)
//   resetSchema: Record<string, unknown> | (() => Record<string, unknown>) | (() => Promise<Record<string, unknown>>)
//   saveSchema: Record<string, unknown> | (() => Record<string, unknown>) | (() => Promise<Record<string, unknown>>)
//   func?: (...args: any[]) => any
//   egress?: (...args: any[]) => any
// }

// type IFormData = Record<string, any>
// interface Option {
//   label: string
//   value: string
// }

// const SchemaFormFiddle = (props: IFunctionCallerProps): JSX.Element => {
//   const { getStoreList, onLoadSchema, saveSchema, func, egress, resetSchema } = props
//   const [collection, setCollection] = useState<any>({})
//   const [isError, setIsError] = useState<boolean>(false)
//   const [isLoading, setIsLoading] = useState<boolean>(true)
//   const [funcList, setFuncList] = useState<string[]>([])
//   const [formData, setFormData] = useState<IFormData>()
//   const [selectedFormType, setSelectedFormType] = useState<Option>()
//   const [show, setShow] = useState()
//   const [openModal, setOpenModal] = useState(false)

//   const onSubmit = (props: IFormData): void => {
//     const { formData } = props
//     setFormData(formData)
//     const output = func?.(...Object.values(formData))
//     setShow((egress != null) ? egress(output) : output)
//   }
//   // handle orientation change
//   const orientation = useOrientation((orientation: boolean) => orientation)

//   const handleUpload = useCallback((data: any) => {
//     setCollection(JSON.parse(data))
//   }, [])

//   const schemaData = (data: { rjsf: any }): void => {
//     setCollection(data?.rjsf)
//   }

//   useEffect(() => {
//     generateInitialData(getStoreList, setFuncList, setIsError, setIsLoading)
//   }, [getStoreList])

//   const handleValue = (value: any): void => {
//     setSelectedFormType(value)
//   }

//   const handleCloseModal = (): void => {
//     setOpenModal(false)
//   }

//   const handleOpenModal = (): void => {
//     setOpenModal(true)
//   }

//   const newJsonSpecValue = async (val: any): Promise<void> => {
//     setIsLoading(true)
//     const data = await onLoadSchema(selectedFormType?.label)
//     setCollection(data?.rjsf)
//     setIsLoading(false)
//   }

//   return (
//     <main>
//       {isError
//         ? (<Alert severity="error" className="errorMessage">
//           There is an Error getting Store List data
//         </Alert>)
//         : (
//         <main className="main-json-fiddle">
//            {isLoading && <LoadingOverlay />}
//           <h1 className="center">JSON Form Fiddle</h1>
//           <div className="inputs-fiddle">
//             <SearchBox
//               handleValue={handleValue}
//               data={funcList}
//               onLoadSchema={onLoadSchema}
//               schemaData={schemaData}
//             />
//           </div>

//           <section className="jsonFiddle">
//             <SplitterLayout
//               vertical={orientation}
//               percentage={true}
//               secondaryInitialSize={50}
//               secondaryMinSize={50}
//             >
//               <div className="fiddle-left-side">
//                 <div className="schema-layout layout-common">
//                   <Editors
//                     data={collection}
//                     onDataUploaded={handleUpload}
//                     title="Specifications"
//                     saveSchema={saveSchema}
//                     formType={selectedFormType}
//                     handleOpenModal={handleOpenModal}
//                   />
//                 </div>
//               </div>
//               <div className="fiddle-right-side">
//                 {!isEmpty(collection) && (
//                   <Form
//                     validator={validator}
//                     {...collection}
//                     onSubmit={onSubmit}
//                     formData={formData} // remove this to clear the value once the submit button is clicked
//                   />
//                 )}
//                 {show}
//               </div>
//             </SplitterLayout>
//           </section>
//         </main>
//           )}
//         <CustomModal
//             open={openModal}
//             handleClose={handleCloseModal}
//             title="Reset the Specification Panel"
//             content={<ResetAll handleClose={handleCloseModal} resetSchema={resetSchema}
//             formType={selectedFormType} newJsonSpecValue={newJsonSpecValue}/>
//           }
//         />
//         <ReactToastMessage />
//     </main>
//   )
// }

// SchemaFormFiddle.defaultProps = {
//   getStoreList: [],
//   onLoadSchema: {},
//   saveSchema: {}
// }

// export default memo(SchemaFormFiddle)
// function generateInitialData (
//   DagFuncList: any[] | (() => any[]) | (() => Promise<any[]>),
//   setFuncList: React.Dispatch<any>,
//   setIsError: React.Dispatch<React.SetStateAction<boolean>>,
//   setIsLoading: React.Dispatch<React.SetStateAction<boolean>>
// ): void {
//   // setIsLoading(true);
//   if (isEmpty(DagFuncList)) {
//     setFuncList([]) // Return an empty array if DagFuncList is not provided
//     setIsError(true)
//   }

//   if (isObject(DagFuncList)) {
//     setIsError(false)
//     const result: any = DagFuncList
//     if (isFunction(result?.then)) {
//       // Check if the result of the function is a promise
//       result.then((dataArray: any) => {
//         if (dataArray.length > 0) {
//           setFuncList(dataArray)
//         } else {
//           setIsError(true)
//           setFuncList([])
//         }
//         setIsLoading(false)
//       })
//     } else {
//       setFuncList(result)
//     }
//     // setIsLoading(false)
//   }
// }
